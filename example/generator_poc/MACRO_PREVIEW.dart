// MACRO_PREVIEW.dart

// This file demonstrates how Dart Macros (experimental feature) will eliminate
// 1. The need for `build_runner` (code generation happens in real-time).
// 2. The need for manual `NanoObserved` wrappers (macro wraps the build method).

import 'package:flutter/material.dart';

// =============================================================================
// 1. LOGIC: No `build_runner`, No Mixins
// =============================================================================

/// The `@nano` macro introspects the class and:
/// 1. Creates private `Atom` fields for each public field.
/// 2. Rewrites the getters/setters to use the Atoms.
@nano
class CounterLogic {
  int count = 0; // Macro transforms this!

  void increment() {
    count++; // Just works.
  }
}

/*
  // BEHIND THE SCENES (Generated by Macro in memory):
  class CounterLogic {
    final Atom<int> _countAtom = Atom(0);

    int get count {
      _countAtom.reportRead();
      return _countAtom.value;
    }

    set count(int value) {
      _countAtom.value = value;
    }

    void increment() {
      count++;
    }
  }
*/

// =============================================================================
// 2. UI: No `NanoObserved` Wrapper
// =============================================================================

/// The `@NanoWidget` macro introspects the `build` method and wraps its body
/// with `Nano.track`.
@NanoWidget
class CounterPage extends StatelessWidget {
  final logic = CounterLogic();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        // Implicitly tracks `logic.count` because the Macro wrapped this block!
        child: Text('${logic.count}'),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: logic.increment,
        child: Icon(Icons.add),
      ),
    );
  }
}

/*
  // BEHIND THE SCENES (Generated by Macro in memory):
  class CounterPage extends StatelessWidget {
    final logic = CounterLogic();

    @override
    Widget build(BuildContext context) {
      // The macro injects the tracking scope around your original code
      return NanoObserved( // or internal equivalent
        builder: (context) {
           return Scaffold(
             body: Center(
               child: Text('${logic.count}'),
             ),
             // ...
           );
        }
      );
    }
  }
*/
